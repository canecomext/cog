/**
 * Spatial Utilities Generator
 *
 * Generates conversion utilities for PostGIS geometry types.
 * Converts between GeoJSON (JavaScript/JSON standard) and WKT (PostGIS format).
 */

export class SpatialUtilsGenerator {
  /**
   * Generate the spatial-utils.ts file content
   */
  generate(): string {
    let code = '';

    // Add file header
    code += this.generateHeader();

    // Add type definitions
    code += this.generateTypes();

    // Add GeoJSON to WKT converter
    code += this.generateGeoJsonToWKT();

    // Add WKT to GeoJSON converter
    code += this.generateWKTToGeoJSON();

    // Add helper functions
    code += this.generateHelpers();

    return code;
  }

  private generateHeader(): string {
    return `/**
 * Spatial Utilities for PostGIS Geometry Conversion
 *
 * Converts between GeoJSON (JavaScript/JSON standard) and WKT/EWKT (PostGIS format).
 *
 * GeoJSON Format: { type: 'Point', coordinates: [lon, lat] }
 * WKT Format: SRID=4326;POINT(lon lat)
 *
 * Generated by COG - Do not modify manually
 */

`;
  }

  private generateTypes(): string {
    return `// GeoJSON types
export type GeoJSONPoint = {
  type: 'Point';
  coordinates: [number, number];
};

export type GeoJSONLineString = {
  type: 'LineString';
  coordinates: Array<[number, number]>;
};

export type GeoJSONPolygon = {
  type: 'Polygon';
  coordinates: Array<Array<[number, number]>>;
};

export type GeoJSONMultiPoint = {
  type: 'MultiPoint';
  coordinates: Array<[number, number]>;
};

export type GeoJSONMultiLineString = {
  type: 'MultiLineString';
  coordinates: Array<Array<[number, number]>>;
};

export type GeoJSONMultiPolygon = {
  type: 'MultiPolygon';
  coordinates: Array<Array<Array<[number, number]>>>;
};

export type GeoJSON =
  | GeoJSONPoint
  | GeoJSONLineString
  | GeoJSONPolygon
  | GeoJSONMultiPoint
  | GeoJSONMultiLineString
  | GeoJSONMultiPolygon;

`;
  }

  private generateGeoJsonToWKT(): string {
    return `/**
 * Convert GeoJSON object to WKT/EWKT string for PostGIS
 *
 * @param geojson - GeoJSON geometry object
 * @param srid - Spatial Reference System ID (e.g., 4326 for WGS 84)
 * @returns WKT string with SRID prefix (e.g., "SRID=4326;POINT(lon lat)")
 */
export function geoJsonToWKT(geojson: GeoJSON, srid?: number): string {
  let wkt: string;

  switch (geojson.type) {
    case 'Point':
      wkt = pointToWKT(geojson.coordinates);
      break;

    case 'LineString':
      wkt = lineStringToWKT(geojson.coordinates);
      break;

    case 'Polygon':
      wkt = polygonToWKT(geojson.coordinates);
      break;

    case 'MultiPoint':
      wkt = multiPointToWKT(geojson.coordinates);
      break;

    case 'MultiLineString':
      wkt = multiLineStringToWKT(geojson.coordinates);
      break;

    case 'MultiPolygon':
      wkt = multiPolygonToWKT(geojson.coordinates);
      break;

    default:
      throw new Error(\`Unsupported GeoJSON type: \${(geojson as any).type}\`);
  }

  // Add SRID prefix if provided
  return srid ? \`SRID=\${srid};\${wkt}\` : wkt;
}

`;
  }

  private generateWKTToGeoJSON(): string {
    return `/**
 * Convert WKT/EWKT string or EWKB hex string to GeoJSON object
 *
 * @param value - WKT string (with or without SRID prefix) or EWKB hex string
 * @returns GeoJSON geometry object
 */
export function wktToGeoJSON(value: string | Buffer): GeoJSON {
  // Handle Buffer (from database binary format)
  if (value instanceof Buffer || (typeof value === 'object' && value !== null && 'buffer' in value)) {
    const hex = value instanceof Buffer ? value.toString('hex') : Buffer.from(value as any).toString('hex');
    return parseEWKB(hex);
  }

  // Handle hex string (EWKB format from PostgreSQL)
  if (typeof value === 'string' && /^[0-9a-fA-F]+$/.test(value)) {
    return parseEWKB(value);
  }

  // Handle WKT string
  const wkt = String(value);

  // Remove SRID prefix if present (e.g., "SRID=4326;POINT(...)" -> "POINT(...)")
  const cleaned = wkt.replace(/^SRID=\\d+;/, '');

  // Extract geometry type and coordinates
  const typeMatch = cleaned.match(/^(\\w+)\\s*\\((.+)\\)$/i);
  if (!typeMatch) {
    throw new Error(\`Invalid WKT format: \${wkt}\`);
  }

  const [, type, coordsStr] = typeMatch;
  const upperType = type.toUpperCase();

  switch (upperType) {
    case 'POINT':
      return parsePoint(coordsStr);

    case 'LINESTRING':
      return parseLineString(coordsStr);

    case 'POLYGON':
      return parsePolygon(coordsStr);

    case 'MULTIPOINT':
      return parseMultiPoint(coordsStr);

    case 'MULTILINESTRING':
      return parseMultiLineString(coordsStr);

    case 'MULTIPOLYGON':
      return parseMultiPolygon(coordsStr);

    default:
      throw new Error(\`Unsupported WKT geometry type: \${type}\`);
  }
}

`;
  }

  private generateHelpers(): string {
    return `// ============================================
// EWKB Parser for PostgreSQL binary format
// ============================================

/**
 * Parse EWKB (Extended Well-Known Binary) hex string to GeoJSON
 * This is the binary format that PostgreSQL returns for PostGIS geometries
 */
function parseEWKB(hex: string): GeoJSON {
  const buffer = new Uint8Array(hex.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16)));
  let offset = 0;

  // Read byte order (1 byte)
  const byteOrder = buffer[offset++];
  const littleEndian = byteOrder === 1;

  // Helper to read numbers
  const readUInt32 = (): number => {
    const value = new DataView(buffer.buffer, offset, 4).getUint32(0, littleEndian);
    offset += 4;
    return value;
  };

  const readFloat64 = (): number => {
    const value = new DataView(buffer.buffer, offset, 8).getFloat64(0, littleEndian);
    offset += 8;
    return value;
  };

  // Read geometry type (4 bytes) - includes SRID flag
  const geometryTypeInt = readUInt32();
  const hasSRID = (geometryTypeInt & 0x20000000) !== 0;
  const geometryType = geometryTypeInt & 0xFF;

  // Skip SRID if present (4 bytes)
  if (hasSRID) {
    offset += 4;
  }

  // Parse based on geometry type
  switch (geometryType) {
    case 1: // Point
      return {
        type: 'Point',
        coordinates: [readFloat64(), readFloat64()],
      };

    case 2: { // LineString
      const numPoints = readUInt32();
      const coordinates: Array<[number, number]> = [];
      for (let i = 0; i < numPoints; i++) {
        coordinates.push([readFloat64(), readFloat64()]);
      }
      return {
        type: 'LineString',
        coordinates,
      };
    }

    case 3: { // Polygon
      const numRings = readUInt32();
      const coordinates: Array<Array<[number, number]>> = [];
      for (let i = 0; i < numRings; i++) {
        const numPoints = readUInt32();
        const ring: Array<[number, number]> = [];
        for (let j = 0; j < numPoints; j++) {
          ring.push([readFloat64(), readFloat64()]);
        }
        coordinates.push(ring);
      }
      return {
        type: 'Polygon',
        coordinates,
      };
    }

    case 4: { // MultiPoint
      const numPoints = readUInt32();
      const coordinates: Array<[number, number]> = [];
      for (let i = 0; i < numPoints; i++) {
        offset++; // Skip byte order
        readUInt32(); // Skip geometry type
        coordinates.push([readFloat64(), readFloat64()]);
      }
      return {
        type: 'MultiPoint',
        coordinates,
      };
    }

    case 5: { // MultiLineString
      const numLines = readUInt32();
      const coordinates: Array<Array<[number, number]>> = [];
      for (let i = 0; i < numLines; i++) {
        offset++; // Skip byte order
        readUInt32(); // Skip geometry type
        const numPoints = readUInt32();
        const line: Array<[number, number]> = [];
        for (let j = 0; j < numPoints; j++) {
          line.push([readFloat64(), readFloat64()]);
        }
        coordinates.push(line);
      }
      return {
        type: 'MultiLineString',
        coordinates,
      };
    }

    case 6: { // MultiPolygon
      const numPolygons = readUInt32();
      const coordinates: Array<Array<Array<[number, number]>>> = [];
      for (let i = 0; i < numPolygons; i++) {
        offset++; // Skip byte order
        readUInt32(); // Skip geometry type
        const numRings = readUInt32();
        const polygon: Array<Array<[number, number]>> = [];
        for (let j = 0; j < numRings; j++) {
          const numPoints = readUInt32();
          const ring: Array<[number, number]> = [];
          for (let k = 0; k < numPoints; k++) {
            ring.push([readFloat64(), readFloat64()]);
          }
          polygon.push(ring);
        }
        coordinates.push(polygon);
      }
      return {
        type: 'MultiPolygon',
        coordinates,
      };
    }

    default:
      throw new Error(\`Unsupported EWKB geometry type: \${geometryType}\`);
  }
}

// ============================================
// GeoJSON to WKT Helpers
// ============================================

function pointToWKT(coords: [number, number]): string {
  return \`POINT(\${coords[0]} \${coords[1]})\`;
}

function lineStringToWKT(coords: Array<[number, number]>): string {
  const points = coords.map(c => \`\${c[0]} \${c[1]}\`).join(', ');
  return \`LINESTRING(\${points})\`;
}

function polygonToWKT(coords: Array<Array<[number, number]>>): string {
  const rings = coords.map(ring => {
    const points = ring.map(c => \`\${c[0]} \${c[1]}\`).join(', ');
    return \`(\${points})\`;
  }).join(', ');
  return \`POLYGON(\${rings})\`;
}

function multiPointToWKT(coords: Array<[number, number]>): string {
  const points = coords.map(c => \`(\${c[0]} \${c[1]})\`).join(', ');
  return \`MULTIPOINT(\${points})\`;
}

function multiLineStringToWKT(coords: Array<Array<[number, number]>>): string {
  const lines = coords.map(line => {
    const points = line.map(c => \`\${c[0]} \${c[1]}\`).join(', ');
    return \`(\${points})\`;
  }).join(', ');
  return \`MULTILINESTRING(\${lines})\`;
}

function multiPolygonToWKT(coords: Array<Array<Array<[number, number]>>>): string {
  const polygons = coords.map(polygon => {
    const rings = polygon.map(ring => {
      const points = ring.map(c => \`\${c[0]} \${c[1]}\`).join(', ');
      return \`(\${points})\`;
    }).join(', ');
    return \`(\${rings})\`;
  }).join(', ');
  return \`MULTIPOLYGON(\${polygons})\`;
}

// ============================================
// WKT to GeoJSON Helpers
// ============================================

function parseCoordPair(str: string): [number, number] {
  const [lon, lat] = str.trim().split(/\\s+/).map(Number);
  return [lon, lat];
}

function parsePoint(coordsStr: string): GeoJSONPoint {
  return {
    type: 'Point',
    coordinates: parseCoordPair(coordsStr),
  };
}

function parseLineString(coordsStr: string): GeoJSONLineString {
  const coordinates = coordsStr
    .split(',')
    .map(pair => parseCoordPair(pair));
  return {
    type: 'LineString',
    coordinates,
  };
}

function parsePolygon(coordsStr: string): GeoJSONPolygon {
  // Match ring groups: ((x y, x y, ...))
  const ringMatches = coordsStr.match(/\\(([^()]+)\\)/g);
  if (!ringMatches) {
    throw new Error(\`Invalid POLYGON format: \${coordsStr}\`);
  }

  const coordinates = ringMatches.map(ring => {
    // Remove parentheses and parse coordinates
    const cleaned = ring.slice(1, -1);
    return cleaned.split(',').map(pair => parseCoordPair(pair));
  });

  return {
    type: 'Polygon',
    coordinates,
  };
}

function parseMultiPoint(coordsStr: string): GeoJSONMultiPoint {
  // MULTIPOINT can be: (x y), (x y) or just: x y, x y
  const points = coordsStr
    .replace(/[()]/g, '')
    .split(',')
    .map(pair => parseCoordPair(pair));

  return {
    type: 'MultiPoint',
    coordinates: points,
  };
}

function parseMultiLineString(coordsStr: string): GeoJSONMultiLineString {
  // Match line groups: ((x y, x y, ...))
  const lineMatches = coordsStr.match(/\\(([^()]+)\\)/g);
  if (!lineMatches) {
    throw new Error(\`Invalid MULTILINESTRING format: \${coordsStr}\`);
  }

  const coordinates = lineMatches.map(line => {
    const cleaned = line.slice(1, -1);
    return cleaned.split(',').map(pair => parseCoordPair(pair));
  });

  return {
    type: 'MultiLineString',
    coordinates,
  };
}

function parseMultiPolygon(coordsStr: string): GeoJSONMultiPolygon {
  // Match polygon groups: (((x y, x y, ...)))
  // This is complex - need to match nested parentheses
  const polygons: Array<Array<Array<[number, number]>>> = [];

  // Split by polygon boundaries - look for ),( pattern at depth 2
  let depth = 0;
  let currentPolygon = '';

  for (let i = 0; i < coordsStr.length; i++) {
    const char = coordsStr[i];

    if (char === '(') {
      depth++;
      currentPolygon += char;
    } else if (char === ')') {
      depth--;
      currentPolygon += char;

      // If we're back to depth 0 and have content, we completed a polygon
      if (depth === 0 && currentPolygon.trim()) {
        // Parse this polygon
        const ringMatches = currentPolygon.match(/\\(([^()]+)\\)/g);
        if (ringMatches) {
          const rings = ringMatches.map(ring => {
            const cleaned = ring.slice(1, -1);
            return cleaned.split(',').map(pair => parseCoordPair(pair));
          });
          polygons.push(rings);
        }
        currentPolygon = '';
      }
    } else {
      currentPolygon += char;
    }
  }

  return {
    type: 'MultiPolygon',
    coordinates: polygons,
  };
}
`;
  }
}
