/**
 * Filter Utilities Generator
 *
 * Generates shared utilities for filtering in REST endpoints and domain layer.
 * Includes type definitions, filter parsing, validation, and SQL building.
 */

export class FilterUtilsGenerator {
  /**
   * Generate the filter.utils.ts file content
   */
  generate(): string {
    let code = '';

    code += this.generateHeader();
    code += this.generateTypes();
    code += this.generateOperatorsByType();
    code += this.generateParseWhereParam();
    code += this.generateValidateFilter();
    code += this.generateBuildWhereSQL();
    code += this.generateStripUnexposedFields();
    code += this.generateHelpers();

    return code;
  }

  private generateHeader(): string {
    return `/**
 * Filter Utilities for REST API and Domain Layer
 *
 * Provides type-safe filtering capabilities with:
 * - Base64-encoded JSON filter parsing
 * - Filter validation against model field metadata
 * - Drizzle ORM SQL condition building
 * - Response field stripping for unexposed fields
 *
 * Generated by COG - Do not modify manually
 */

import {
  eq,
  ne,
  gt,
  gte,
  lt,
  lte,
  like,
  ilike,
  inArray,
  notInArray,
  isNull,
  isNotNull,
  and,
  or,
  arrayContains,
  arrayOverlaps,
  type SQL,
  type AnyColumn,
} from 'drizzle-orm';
import type { PgTable } from 'drizzle-orm/pg-core';

// Re-export SQL type for use in domain layer
export type { SQL };

`;
  }

  private generateTypes(): string {
    return `// ============================================
// Filter Types
// ============================================

/**
 * Supported filter operators by category
 */
export type FilterOperator =
  // Equality (all types)
  | 'eq'
  | 'neq'
  // Comparison (numeric, date)
  | 'gt'
  | 'gte'
  | 'lt'
  | 'lte'
  // Pattern matching (string, text)
  | 'like'
  | 'ilike'
  // Set membership (all types)
  | 'in'
  | 'nin'
  // Null checks (all types)
  | 'isNull'
  // Array operations (array types)
  | 'contains'
  | 'overlaps';

/**
 * Single filter condition
 */
export interface FilterCondition {
  field: string;
  op: FilterOperator;
  value: unknown;
}

/**
 * Logical grouping of filter conditions (recursive)
 */
export interface FilterGroup {
  and?: (FilterCondition | FilterGroup)[];
  or?: (FilterCondition | FilterGroup)[];
}

/**
 * Top-level filter type (can be single condition or group)
 */
export type WhereFilter = FilterCondition | FilterGroup;

/**
 * Field metadata for filter validation
 */
export interface FieldMeta {
  type: string;
  exposed: boolean;
  array: boolean;
}

/**
 * Filter validation result
 */
export interface FilterValidationResult {
  valid: boolean;
  error?: string;
}

/**
 * Check if a value is a WhereFilter object (not raw SQL)
 */
export function isWhereFilter(value: unknown): value is WhereFilter {
  if (!value || typeof value !== 'object') return false;
  const obj = value as Record<string, unknown>;

  // Check for FilterCondition
  if ('field' in obj && 'op' in obj) return true;

  // Check for FilterGroup
  if ('and' in obj || 'or' in obj) return true;

  return false;
}

`;
  }

  private generateOperatorsByType(): string {
    return `// ============================================
// Operators by Field Type
// ============================================

/**
 * Valid operators for each field type
 */
const operatorsByType: Record<string, FilterOperator[]> = {
  // Text types
  string: ['eq', 'neq', 'like', 'ilike', 'in', 'nin', 'isNull'],
  text: ['eq', 'neq', 'like', 'ilike', 'in', 'nin', 'isNull'],

  // Numeric types
  integer: ['eq', 'neq', 'gt', 'gte', 'lt', 'lte', 'in', 'nin', 'isNull'],
  bigint: ['eq', 'neq', 'gt', 'gte', 'lt', 'lte', 'in', 'nin', 'isNull'],
  decimal: ['eq', 'neq', 'gt', 'gte', 'lt', 'lte', 'in', 'nin', 'isNull'],
  date: ['eq', 'neq', 'gt', 'gte', 'lt', 'lte', 'in', 'nin', 'isNull'],

  // Boolean
  boolean: ['eq', 'isNull'],

  // Identifiers
  uuid: ['eq', 'neq', 'in', 'nin', 'isNull'],
  enum: ['eq', 'neq', 'in', 'nin', 'isNull'],

  // JSON (limited operations)
  json: ['isNull'],
  jsonb: ['isNull'],

  // PostGIS types (limited operations)
  point: ['isNull'],
  linestring: ['isNull'],
  polygon: ['isNull'],
  multipoint: ['isNull'],
  multilinestring: ['isNull'],
  multipolygon: ['isNull'],
  geometry: ['isNull'],
  geography: ['isNull'],
};

/**
 * Additional operators for array fields
 */
const arrayOperators: FilterOperator[] = ['contains', 'overlaps', 'isNull'];

/**
 * Get valid operators for a field type
 */
export function getOperatorsForType(type: string, isArray: boolean): FilterOperator[] {
  if (isArray) {
    return arrayOperators;
  }
  return operatorsByType[type] || ['isNull'];
}

`;
  }

  private generateParseWhereParam(): string {
    return `// ============================================
// Filter Parsing
// ============================================

/**
 * Parse base64-encoded where parameter to filter object
 *
 * @param whereParam - Base64-encoded JSON string from query parameter
 * @returns Parsed WhereFilter object or undefined if invalid/empty
 * @throws Error if the filter is malformed (for 400 response)
 */
export function parseWhereParam(whereParam: string | undefined): WhereFilter | undefined {
  if (!whereParam || whereParam.trim() === '') {
    return undefined;
  }

  try {
    // Decode base64
    const json = atob(whereParam);

    // Parse JSON
    const parsed = JSON.parse(json);

    // Basic structure validation
    if (!parsed || typeof parsed !== 'object') {
      throw new Error('Filter must be an object');
    }

    return parsed as WhereFilter;
  } catch (error) {
    if (error instanceof SyntaxError) {
      throw new Error('Invalid filter: malformed JSON');
    }
    if (error instanceof DOMException) {
      throw new Error('Invalid filter: malformed base64 encoding');
    }
    throw new Error(\`Invalid filter: \${(error as Error).message}\`);
  }
}

`;
  }

  private generateValidateFilter(): string {
    return `// ============================================
// Filter Validation
// ============================================

/**
 * Validate a filter against model field metadata
 *
 * @param filter - The parsed filter object
 * @param fieldMeta - Map of field name to field metadata
 * @returns Validation result with error message if invalid
 */
export function validateFilter(
  filter: WhereFilter,
  fieldMeta: Map<string, FieldMeta>
): FilterValidationResult {
  try {
    validateFilterRecursive(filter, fieldMeta);
    return { valid: true };
  } catch (error) {
    return { valid: false, error: (error as Error).message };
  }
}

/**
 * Recursive filter validation
 */
function validateFilterRecursive(
  filter: WhereFilter,
  fieldMeta: Map<string, FieldMeta>
): void {
  // Handle FilterGroup (and/or)
  if ('and' in filter && filter.and) {
    for (const subFilter of filter.and) {
      validateFilterRecursive(subFilter, fieldMeta);
    }
    return;
  }

  if ('or' in filter && filter.or) {
    for (const subFilter of filter.or) {
      validateFilterRecursive(subFilter, fieldMeta);
    }
    return;
  }

  // Handle FilterCondition
  const condition = filter as FilterCondition;

  // Validate field exists
  const meta = fieldMeta.get(condition.field);
  if (!meta) {
    throw new Error(\`Invalid filter: unknown field '\${condition.field}'\`);
  }

  // Validate field is exposed
  if (!meta.exposed) {
    throw new Error(\`Invalid filter: field '\${condition.field}' is not filterable\`);
  }

  // Validate operator is valid for field type
  const validOperators = getOperatorsForType(meta.type, meta.array);
  if (!validOperators.includes(condition.op)) {
    throw new Error(
      \`Invalid filter: operator '\${condition.op}' not supported for \${meta.array ? 'array' : meta.type} field '\${condition.field}'\`
    );
  }

  // Validate value type for specific operators
  if (condition.op === 'in' || condition.op === 'nin') {
    if (!Array.isArray(condition.value)) {
      throw new Error(
        \`Invalid filter: operator '\${condition.op}' requires an array value for field '\${condition.field}'\`
      );
    }
  }

  if (condition.op === 'isNull') {
    if (typeof condition.value !== 'boolean') {
      throw new Error(
        \`Invalid filter: operator 'isNull' requires a boolean value for field '\${condition.field}'\`
      );
    }
  }

  if (condition.op === 'contains' || condition.op === 'overlaps') {
    if (!Array.isArray(condition.value)) {
      throw new Error(
        \`Invalid filter: operator '\${condition.op}' requires an array value for field '\${condition.field}'\`
      );
    }
  }
}

`;
  }

  private generateBuildWhereSQL(): string {
    return `// ============================================
// SQL Building
// ============================================

/**
 * Convert WhereFilter to Drizzle ORM SQL condition
 *
 * @param filter - The validated filter object
 * @param table - The Drizzle table object
 * @param exposedFields - Set of exposed field names (for safety check)
 * @returns SQL condition or undefined if no valid conditions
 */
export function buildWhereSQL<T extends PgTable>(
  filter: WhereFilter,
  table: T,
  exposedFields: Set<string>
): SQL | undefined {
  return buildWhereSQLRecursive(filter, table, exposedFields);
}

/**
 * Recursive SQL building
 */
function buildWhereSQLRecursive<T extends PgTable>(
  filter: WhereFilter,
  table: T,
  exposedFields: Set<string>
): SQL | undefined {
  // Handle FilterGroup with AND
  if ('and' in filter && filter.and) {
    const conditions = filter.and
      .map((f) => buildWhereSQLRecursive(f, table, exposedFields))
      .filter((c): c is SQL => c !== undefined);

    if (conditions.length === 0) return undefined;
    if (conditions.length === 1) return conditions[0];
    return and(...conditions);
  }

  // Handle FilterGroup with OR
  if ('or' in filter && filter.or) {
    const conditions = filter.or
      .map((f) => buildWhereSQLRecursive(f, table, exposedFields))
      .filter((c): c is SQL => c !== undefined);

    if (conditions.length === 0) return undefined;
    if (conditions.length === 1) return conditions[0];
    return or(...conditions);
  }

  // Handle FilterCondition
  const { field, op, value } = filter as FilterCondition;

  // Skip unexposed fields (safety check - should already be validated)
  if (!exposedFields.has(field)) {
    return undefined;
  }

  // Get column from table
  const column = (table as unknown as Record<string, AnyColumn>)[field];
  if (!column) {
    return undefined;
  }

  // Build SQL condition based on operator
  switch (op) {
    case 'eq':
      return eq(column, value);
    case 'neq':
      return ne(column, value);
    case 'gt':
      return gt(column, value);
    case 'gte':
      return gte(column, value);
    case 'lt':
      return lt(column, value);
    case 'lte':
      return lte(column, value);
    case 'like':
      return like(column, value as string);
    case 'ilike':
      return ilike(column, value as string);
    case 'in':
      return inArray(column, value as unknown[]);
    case 'nin':
      return notInArray(column, value as unknown[]);
    case 'isNull':
      return value ? isNull(column) : isNotNull(column);
    case 'contains':
      return arrayContains(column, value as unknown[]);
    case 'overlaps':
      return arrayOverlaps(column, value as unknown[]);
    default:
      return undefined;
  }
}

`;
  }

  private generateStripUnexposedFields(): string {
    return `// ============================================
// Response Sanitization
// ============================================

/**
 * Strip unexposed fields from response data
 *
 * @param data - The data to sanitize (single object or array)
 * @param unexposedFields - Array of field names to remove
 * @returns Sanitized data with unexposed fields removed
 */
export function stripUnexposedFields<T>(
  data: T,
  unexposedFields: string[]
): T {
  if (unexposedFields.length === 0) {
    return data;
  }

  if (Array.isArray(data)) {
    return data.map((item) => stripUnexposedFields(item, unexposedFields)) as T;
  }

  if (data && typeof data === 'object') {
    const result = { ...data } as Record<string, unknown>;
    for (const field of unexposedFields) {
      delete result[field];
    }
    return result as T;
  }

  return data;
}

`;
  }

  private generateHelpers(): string {
    return `// ============================================
// Utility Functions
// ============================================

/**
 * Encode a filter object to base64 for use in URL query parameter
 *
 * @param filter - The filter object to encode
 * @returns Base64-encoded JSON string
 */
export function encodeFilter(filter: WhereFilter): string {
  return btoa(JSON.stringify(filter));
}

/**
 * Create a simple equality filter
 */
export function eqFilter(field: string, value: unknown): FilterCondition {
  return { field, op: 'eq', value };
}

/**
 * Create a range filter (gte and lte)
 */
export function rangeFilter(field: string, min: unknown, max: unknown): FilterGroup {
  return {
    and: [
      { field, op: 'gte', value: min },
      { field, op: 'lte', value: max },
    ],
  };
}

/**
 * Create an IN filter
 */
export function inFilter(field: string, values: unknown[]): FilterCondition {
  return { field, op: 'in', value: values };
}

/**
 * Create a LIKE filter with wildcards
 */
export function likeFilter(field: string, pattern: string): FilterCondition {
  return { field, op: 'like', value: pattern };
}

/**
 * Create a case-insensitive LIKE filter with wildcards
 */
export function ilikeFilter(field: string, pattern: string): FilterCondition {
  return { field, op: 'ilike', value: pattern };
}

/**
 * Combine multiple filters with AND
 */
export function andFilters(...filters: (FilterCondition | FilterGroup)[]): FilterGroup {
  return { and: filters };
}

/**
 * Combine multiple filters with OR
 */
export function orFilters(...filters: (FilterCondition | FilterGroup)[]): FilterGroup {
  return { or: filters };
}
`;
  }
}
